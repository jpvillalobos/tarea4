---
title: "Tarea 4 - Mineria de Datos e Inteligencia de Negocios"
author: "Jonathan Gonzalez, Gonzalo Rodriguez, Juan P. Villalobos"
date: "05/17/2020"
output:
  # pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#instalar librerias

#install.packages(tibble)
#install.packages(stringr)
#install.packages(rves)
#install.packages(FactoMineR)
#install.packages(ggplot2)

options(repos="https://cran.rstudio.com" )

# cargar librerias necesarias
suppressWarnings(suppressMessages(library(tibble)))
suppressWarnings(suppressMessages(library(stringr)))
suppressWarnings(suppressMessages(library(rvest)))
suppressWarnings(suppressMessages(library(FactoMineR)))
suppressWarnings(suppressMessages(library(ggplot2)))
suppressWarnings(suppressMessages(library(purrr)))
suppressWarnings(suppressMessages(library(dplyr)))
suppressWarnings(suppressMessages(library(cluster)))
suppressWarnings(suppressMessages(library(factoextra)))
suppressWarnings(suppressMessages(library(knitr)))
suppressWarnings(suppressMessages(library(fpc)))
install.packages("foreign")
```
# Web Mining y Clustering
___
## Objetivos

### Negocio
* Ejercicio Académico.

> Construir clusters de los jugadores mas valiosos de la NBA segun su porcentaje de efectividad en tiros.

### Minería de Datos
* Desarrollar un modelo utilizando reglas de clustering.

* Aplicar parcialmente la metodología CRISP-DM para resolver un caso básico de minería de datos.

* Extraer datos de una página web para ser analizados posteriormente.

* Aplicar expresiones regulares para procesar datos textuales.

* Aplicar un algoritmo de clustering a los datos extraídos.

### Criterio de éxito

* Aplicar los conceptos vistos en clase correctamente.

## Entendimiento de los datos

### Exploración de datos

* ***Busque en Internet una página web con datos que sean de su interés. Los datos deben ser parte de lo que la página presenta, es decir, deben ser tablas, párrafos, etc. visibles al cargar la página.***

Para la presente tarea se utilizarán las siguientes páginas web:

* Estadísticas de los jugadores mas valiosos de la NBA y ABA (MVPs) según Basketball Reference:
[https://www.basketball-reference.com/awards/mvp.html](https://www.basketball-reference.com/awards/mvp.html)

* Información de jugadores mas valiosos de la NBA (MVPs) según Wikipedia:
[https://en.wikipedia.org/wiki/NBA_Most_Valuable_Player_Award](https://en.wikipedia.org/wiki/NBA_Most_Valuable_Player_Award)


```{r}
#leer los datos en formato html desde las paginas web, Wiki Basketball MVP
NBA_MVP_pageURL<-'https://www.basketball-reference.com/awards/mvp.html'
Wiki_MVP_pageURL<-'https://en.wikipedia.org/wiki/NBA_Most_Valuable_Player_Award'
nba_pageHTML<- read_html(NBA_MVP_pageURL,encoding = 'UTF-8')
wiki_pageHTML<- read_html(Wiki_MVP_pageURL,encoding = 'UTF-8')
  
#extraer las tablas del codigo html
nba_pageTables<- html_table(nba_pageHTML,fill=TRUE)
wiki_pageTables<- html_table(wiki_pageHTML,fill=TRUE)
```

#### Exploración de datos de www.basketball-reference.com

La página de Basketball Reference tiene: ```r length(nba_pageTables)``` tablas, cuyos encabezados son:

```{r}
#mostrar los encabezados de cada tabla
str(nba_pageTables)
```

> El resultado anterior muestra un error en los encabezados de las tablas debido al estilo del sitio web. Además se aprecia que las dos primeras tablas deben unirse y que, debido a estadísticas faltantes, procederemos a ignorar/eliminar la tercera para el ejercicio de clustering.

La cantidad de datos vacíos en la tabla #1 es: ```r sum(nba_pageTables[[1]] == "")```  
La cantidad de datos vacíos en la tabla #2 es: ```r sum(nba_pageTables[[2]] == "")```

> Esta cantidad de datos vacíos nos indica que los datos deben limpiarse un poco antes de ser procesados.

#### Exploración de datos de Wikipedia

La página de NBA tiene: ```r length(wiki_pageTables)``` tablas, cuyos encabezados son:

```{r}
#mostrar los encabezados de cada tabla
str(wiki_pageTables) 
```

> El resultado anterior nos muestra que los datos a extraer están en la tabla número 6 y que sus encabezados no necesitan limpieza adicional.

La cantidad de datos vacios en la tabla #6 es: ```r sum(wiki_pageTables[[6]] == "")```  

> Esta cantidad de datos vacios nos indica una alta calidad en los datos.


### Preparación de los datos

* ***Seleccione los datos de su interés en las páginas previamente identificadas.***
```{r}
#agregar y almacenar la tablas #1 y #2 de la NBA
nba_Table<- nba_pageTables[[1]]

#seleccionar la primera fila como encabezados.
names(nba_Table) <- nba_Table[1,]

#almacenar la tabla #3 de la pagina de Wiki, no necesita cambios por el momento.
wiki_Table<- wiki_pageTables[[6]]

kable(nba_Table)
kable(wiki_Table)
```


* ***Limpieza de los datos: limpie lo que sea necesario aplicando expresiones regulares.***

> Según la vista  anterior se observa que de la tabla nba_table debe eliminarse la primera fila pues contiene el encabezado. También se decide que las columnas "Age" (la edad del jugador), "lg" (el nombre de la liga) y "voting" (que es un enlace a otra página con el desglose de las votaciones por el MVP de la temporada) no serán utilizadas para hacer el clustering de la información. De igual forma se eliminarán las columnas WS y WS/48 (win shares y win shares by 48 minutes, respectivamente) puesto que al ser "métricas avanzadas" utilizan las otras estadísticas como parte de su cálculo, es decir, introducen una dependencia linear.

> Con respecto a la tabla wiki_table se observa que que deben ser removidas las columnas Team y Nationality pues no son de utilidad para el análisis. La columna "Player" tambien debe eliminarse porque está duplicada en la tabla nba_table

```{r}
# Eliminar las columnas: "Age", Lg", "Voting", "Tm", "WS", "WS/48" del frame nba_Table pues no aportan datos importantes al modelo. 
nba_Table$Age <- NULL
nba_Table$Lg <- NULL
nba_Table$Voting <- NULL
nba_Table$Tm <- NULL
nba_Table$WS <- NULL
nba_Table$"WS/48" <- NULL

# Eliminar las filas que contienen encabezados como datos (busca un encabezado dentro de los datos)
nba_Table<- nba_Table[ grep("Season", nba_Table$Season, invert = TRUE) , ]

kable(nba_Table)

# Eliminar las columnas: "Player" del frame wiki_Table (ya está en la otra tabla), Nationality y Team (no serán tomadas en cuenta para el análisis)
wiki_Table$Player <- NULL
wiki_Table$Nationality <- NULL
wiki_Table$Team <- NULL

# Reemplazar caracteres invalidos para "-" en el campo "Season". (Sí, son diferentes).
wiki_Table$Season <- str_replace(wiki_Table$Season,'\\–','\\-')

kable(wiki_Table)
```

* ***Construcción de nuevos datos (atributos). Si no aplica, indíquelo. Si construye nuevas columnas o atributos, explique.***

> No se contruirán nuevos atributos, sin embargo en esta fase se unirán los datos de ambas páginas utilizando el campo común "Season".

```{r}
# Unir ambas tablas en una sola con todos los atributos.
players_table <- merge(nba_Table,wiki_Table, by = "Season")

# Reorganizar la posición de las columnas para facilitar la visualización
players_table<- players_table[c(1,2,13,3,4,5,6,7,8,9,10,11,12)]

kable(players_table)

```

* ***Transformaciones aplicadas a los datos. Describa las transformaciones realizadas.***

> Primero se reemplaza los nombres de las filas del dataframe por una combinación de las columnas Season, Player y Position para facilitar la lectura de los resultados. Una vez realizado este cambio esas columnas se eliminan.

```{r}
players_table$id <- paste(players_table$Player,'(',players_table$Season,')','-',players_table$Position)
rownames(players_table) <- players_table$id

players_table$id <- NULL
players_table$Player <- NULL
players_table$Season <- NULL
players_table$Position <- NULL

kable(players_table)

```

> Luego se aplica una transformación básica, mutar las columnas a valores numéricos. Luego se procede a eliminar las filas con valores vacíos: un total de 24 que comprenden aquellas temporadas previas a 1979-1980 cuando no se llevaba registro de estadísticas como robos, bloqueos y el tiro de 3 puntos no existía. Finalmente se normalizan las columnas numéricas para evitar que las diferencias en magnitudes perjudiquen el modelo.

```{r}

# Transformar las columnas con valores númericos a su correspondiente tipo.
sapply(players_table, class)

numeric_columns <- c(1:10)
players_table[ , numeric_columns] <- apply(players_table[ , numeric_columns], 2,  # Especifica la funcion en la llamada
                                           function(x) as.numeric(as.character(x)))
sapply(players_table, class)
kable(players_table)

# Eliminar filas con valores vacíos
na_omitted <- na.omit(players_table) 
kable(na_omitted)

# Normalizacion de los datos
# players_normal <- na_omitted %>% mutate_at(1:10, funs((. - mean(.))/sd(.)))
players_normal <- as.data.frame(scale(na_omitted))
kable(players_normal)

```


### Fase de modelado

***Para esta fase se le solicita que seleccione dos de los algoritmos de clustering vistos en clase, o bien ejecutar dos veces sólo uno de los algoritmos estudiados pero usando diferentes parámetros cada vez.***

> Las técnicas a utilizar son k-means y LA OTRA

#### Construcción de modelo k-means (5,20)

Los parámetros a utilizar son: k = 5 centroides: utilizando un poco de conocimiento previo de los datos, conscientes de que existen 5 posiciones diferentes en el baloncesto. nstart = 20 configuraciones iniciales: aprovechando el modesto tamaño del set de datos.
    
```{r}

# ejecución del algoritmo kmeans con los parámetros elegidos
clusters <- kmeans(players_normal,5,nstart=20)

# obtener cantidad de registros en cada cluster y los centroides
descClusters<- data.frame(clusters$size,clusters$centers)
kable(descClusters)

# crear un data frame combinando el cluster asignado y los atributos originales
resultado <- data.frame(clusters$cluster,players_normal)
names(resultado)[1] <- "cluster"
kable(resultado[order(resultado$cluster),])
```  
    
* ***Descripción del modelo obtenido (incluya al menos un gráfico por modelo)***

```{r}
# modelo obtenido

# grafico modelo #1

plotcluster(players_normal, clusters$cluster)

# construir un grafico
#ggplot(players_ds,
#     aes(PTS,BLK,
#         color = clusters$cluster)) + geom_point()+ ggtitle(label='Distribución por cluster')

# otra forma de visualizar los clusters
fviz_cluster(clusters,data=players_normal[,c(1,2)],palette='jco',ggtheme = theme_minimal())


install.packages("ggplot2")
ggparcoord(data=players_normal,columns=c(1:10))

```  
* ***Evaluación del modelo***
    
```{r}
# evaluacion modelo #1
# cálculo del score Silhouette
score_sil<- silhouette(clusters$cluster,daisy(players_normal))

# cálculo del valor óptimo de k usando el score silhouette
fviz_nbclust(players_normal,kmeans,method = 'silhouette',k.max = 10)

# cálculo del valor óptimo de k usando el método del codo
fviz_nbclust(players_normal,kmeans,method = 'wss',k.max = 10)

# cálculo del valor óptimo de k usando la estadística gap
fviz_nbclust(players_normal,kmeans,method = 'gap_stat',k.max = 10)

```

#### Construcción de modelo k-means (2,20)

Los parámetros a utilizar son: k = 2 centroides: siguiendo la recomendación dada por silhouette. nstart = 20 configuraciones iniciales: aprovechando el modesto tamaño del set de datos.
    
```{r}

# ejecución del algoritmo kmeans con los parámetros elegidos
clusters2 <- kmeans(players_normal,2,nstart=20)

# obtener cantidad de registros en cada cluster y los centroides
descClusters2<- data.frame(clusters2$size,clusters2$centers)
kable(descClusters2)

# crear un data frame combinando el cluster asignado y los atributos originales
resultado2 <- data.frame(clusters2$cluster,players_normal)
names(resultado2)[1] <- "cluster"
kable(resultado2[order(resultado2$cluster),])
```

* ***Descripción del modelo obtenido (incluya al menos un gráfico por modelo)***

```{r}
# modelo obtenido

# grafico modelo #2

plotcluster(players_normal, clusters2$cluster)

# construir un grafico
#ggplot(players_ds,
#     aes(PTS,BLK,
#         color = clusters$cluster)) + geom_point()+ ggtitle(label='Distribución por cluster')

# otra forma de visualizar los clusters
fviz_cluster(clusters2,data=players_normal[,c(1,2)],palette='jco',ggtheme = theme_minimal())
```  

* ***Evaluación del modelo***
    
```{r}
# evaluacion modelo #1
# cálculo del score Silhouette
score_sil<- silhouette(clusters2$cluster,daisy(players_normal))

# cálculo del valor óptimo de k usando el score silhouette
fviz_nbclust(players_normal,kmeans,method = 'silhouette',k.max = 10)

# cálculo del valor óptimo de k usando el método del codo
fviz_nbclust(players_normal,kmeans,method = 'wss',k.max = 10)

# cálculo del valor óptimo de k usando la estadística gap
fviz_nbclust(players_normal,kmeans,method = 'gap_stat',k.max = 10)

```